## 이진 탐색 트리에 대한 이해

- 계층적 자료구조
- 그래프의 일종 (노드와 간선으로 이루어짐)
	- 단방향성 그래프
	- 부모-자식으로 노드의 관계가 형성됨
	- Root 노드를 제외한 모든 노드는 부모노드는 1개만 가질 수 있음 (일반트리)
	- 모든 노드는 최대 2개(0~2)의 자식만 가질 수 있음. (이진트리)
	- 각 노드는 좌측에 자기보다 작은 수를, 우측에 자기보다 큰 수를 배치함 (이진탐색트리)
	- 즉, 자료를 저장할 때 정렬을 하는 이진 트리라는 것


---
## 최소 구현 API

```cpp
template<typename T>
class BinarySearchTree
{
public:
    size_t Size() const;
    bool Empty() const;
    void Clear();

    bool Insert(const T& value);
    bool Find(const T& value) const; 
    bool Erase(const T& value);

    template<typename T>
    void TraversePreOrder(T visit) const;

    template<typename F>
    void TraverseInOrder(T visit) const;

    template<typename F>
    void TraversePostOrder(T visit) const;
};
```


---
### Erase

#### 이진 탐색 트리(BST) 노드 삭제(Erase) 알고리즘 정리

##### 1. 서브트리 재연결 방식 (Subtree Re-attachment)

삭제된 노드의 위치에 한쪽 서브트리를 옮기고, 나머지 서브트리를 해당 서브트리의 끝단에 부착하는 방법임.

- **동작 원리**
    - 삭제 노드의 오른쪽 서브트리를 삭제 위치로 승격시킴
    - 왼쪽 서브트리는 승격된 서브트리의 최솟값 노드(가장 왼쪽 끝) 하단에 연결함
    - 이는 '왼쪽 < 노드 < 오른쪽'이라는 BST의 기본 성질을 이용한 것임
- **특징 및 평가**
    - **장점:** 서브트리 내부의 기존 노드들 간 연결을 수정할 필요 없이 포인터 재연결만으로 수행 가능함. (교체 연산 O(1))
    - **단점:** 삭제 및 삽입이 반복될수록 트리의 높이가 한쪽으로 치우쳐 성능이 저하될 가능성이 큼

##### 2. 후계자 노드 교체 방식 (Successor/Predecessor Replacement)

삭제 노드와 값이 가장 근사한 노드를 찾아 해당 위치로 이동시키는 방법임.

- **동작 원리**
    - 왼쪽 서브트리의 최댓값(Predecessor) 또는 오른쪽 서브트리의 최솟값(Successor)을 선정함
    - 선정된 노드는 삭제될 값과 가장 가깝기 때문에, 위치를 옮겨도 좌우 서브트리의 BST 속성을 위반하지 않음
    - 예를 들어, 왼쪽 최댓값은 삭제 위치로 올라가더라도 해당 서브트리 내의 모든 값보다 크므로 기존 구조를 유지할 수 있음
- **특징 및 평가**
    - **장점:** 기존 트리의 형태를 최대한 유지하므로 1번 방식보다 구조적 안정성이 높음
    - **효율성:** 포인터 이동 연산이 최소화되며, 논리적으로 더 정교한 삭제 방식임

##### 3. 결론

1번 방식은 구현이 단순하나 트리 구조가 무너질 위험이 있는 반면, **2번 방식은 구조적 무결성을 지키면서도 연산 효율이 우수하여 표준적인 삭제 방식으로 적합함.** 이에 따라 2번 방식을 채택하여 구현하는 것이 타당함


---