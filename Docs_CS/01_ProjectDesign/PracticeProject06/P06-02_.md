# 해시 테이블 리사이징과 소수(Prime) 활용의 설계 근거

### 기본개념

### 1. 해시 테이블 크기와 소수의 상관관계

- 해시 테이블의 성능은 **해시 결과가 테이블 전체 인덱스에 균등하게 분포되는지 여부**에 의존함

- 이 균등 분포를 보장하기 위한 핵심 설계 요소 중 하나가 **테이블 크기를 소수(prime number)로 설정하는 것**

#### 1.1 약분(공약수)에 의한 공간 점유 문제

- 입력 키`Key`가 특정 간격 `d`의 배수 형태로 유입되는 경우를 가정함

- 이때 테이블 크기 `Size`와 `d` 사이에 공약수 `gcd(d, Size)`가 존재하면, 실제 인덱스 접근 주기는 다음과 같이 단축됨

$$
\text{Cycle Length} = \frac{\text{Size}}{\gcd(d, \text{Size})}
$$

이 결과:

- 테이블 전체 슬롯이 아닌 **일부 인덱스만 반복적으로 사용**
    
- 나머지 슬롯은 **도달 불가능한 유령 공간(Dead Space)**으로 남음
    
- 클러스터링(Clustering) 증가
    
- 탐색, 삽입 성능의 구조적 저하 발생
	
- 예시: `Size = 100` 이고 입력이 `10의 배수`로 들어올 경우
	  
	- **gcd(d, Size) = 10**
	  
	- 100개의 인덱스 중 10, 20, 30.. 과 같은 **10의 배수에 해당하는 인덱스만 사용됨**
	  
	- 10의 배수 10개의 인덱스를 제외한 90%의 인덱스가 `Dead Space`
	
- 이는 해시 함수 자체가 정상이라 하더라도, **테이블 크기 선택이 잘못되면 구조적으로 성능이 붕괴될 수 있음**을 의미함

#### 1.2 온전한 분모로서의 소수 활용

테이블 크기를 소수로 설정하면 다음 특성이 성립함

- 1과 자기 자신 외에는 약수가 존재하지 않음
    
- 어떤 간격 ( d )의 입력 패턴이 유입되더라도 주기가 단축되지 않음
    
- 결과적으로 **테이블 전체 슬롯을 순회하는 최대 주기(Full Cycle)** 보장
    

#### 1.3 결론

이는 해시 결과의 **인덱스 분산 효과를 수학적으로 최대화하는 조건**이며, 소수 크기 테이블은 단순한 관습이 아닌 **필연적인 설계 선택**


---
### 2. 소수(Prime Number)의 성질과 필터링 원리

#### 2.1 산술의 기본 정리 관점

모든 자연수는 소수들의 곱으로 유일하게 표현됨. 

따라서 소수 판별이란, **해당 수가 이미 존재하는 소수 블록들의 조합인지 여부를 검증하는 과정**으로 해석할 수 있음.

#### 2.2 $6k \pm 1$ 성질

2와 3을 제외한 모든 소수는 다음 형태를 만족함

$$  
6k - 1 \quad \text{또는} \quad 6k + 1  
$$

#### 2.3 근거

다음 형태의 수는 반드시 2 또는 3을 약수로 포함함

- ( 6k )
    
- ( 6k + 2 )
    
- ( 6k + 3 )
    
- ( 6k + 4 )
    
따라서 이 수들은 **소수 후보에서 사전에 배제 가능함**
`6k - 1`은 `6k + 5` 에 대응하는 수이며, `6k + 1` 와 `6k - 1` 만이 소수의 가능성을 가지고 있음


---

### 3. 소수 판별 알고리즘 최적화 (C++)

본 구현은 **수학적 엄밀함과 CPU 실행 특성**을 동시에 고려한 실전형 설계임

#### 3.1 제곱근 제한

약수는 항상 대칭 쌍으로 존재하므로,  

$$
i \times i \le n  
$$

까지만 검사하면 충분함

- 시간 복잡도: $O(\sqrt{n})$
    
- 불필요한 반복 제거
    
#### 3.2 $6k \pm 1$ 기반 순회

반복문을 6 단위로 증가시키며 다음 두 값을 동시에 검사

- ( i )
    
- ( i + 2 )
    
이를 통해:

- 전체 후보 수의 약 1/3만 검사
    
- 기본 순차 검사 대비 연산량 약 66% 절감

### 3.3 분기 예측(Branch Prediction) 관점의 최적화

제곱근 근처에서 ( i + 2 ) 검사는 의미가 없을 수 있으나, 이를 방지하기 위한 별도 분기문을 추가하지 않음

- 추가 if 분기는 CPU 분기 예측 실패 확률 증가
    
- 단순 산술 연산 1회가 분기 실패 비용보다 저렴
    
- 파이프라인 유지 관점에서 유리
	
- **이론적 최소 연산이 아닌, 실제 CPU 실행 비용을 고려한 선택**이었음

### 3.4 구현 코드

```cpp
bool IsPrime(size_t InSize)
{
    if (InSize <= 1) return false;
    if (InSize <= 3) return true; // 2, 3
    if (InSize % 2 == 0 || InSize % 3 == 0) return false;

    for (size_t i = 5; i * i <= InSize; i += 6)
    {
        if (InSize % i == 0 || InSize % (i + 2) == 0)
            return false;
    }
    return true;
}
```


---

### 4. 리사이징(Resizing) 정책 및 안전장치

#### 4.1 리사이징 전략

- 적재율(Load Factor)이 임계치 도달 시 리사이징 수행
    
- 현재 크기의 **약 2.0배 이상인 다음 소수**를 새 테이블 크기로 선택
    
- 모든 기존 요소는 재해싱(Rehashing) 진행

#### 4.2 오버플로우 및 안정성 검증

정수 오버플로우로 인해:

- 계산된 nextSize가 현재 크기보다 작아지는 경우
    
- 무한 루프 또는 메모리 오류 가능성 존재

- nextSize > currentSize 확인
    
- 실패 시 즉시 중단 및 오류 보고


---

## 정리

- 소수 테이블 크기는 선택이 아닌 구조적 필수 조건
    
- $6k \pm 1$ 기반 소수 판별은 이론·실무 모두에서 효율적
    
- 리사이징은 수학적 안전성과 시스템 안정성을 동시에 고려해야 함


---