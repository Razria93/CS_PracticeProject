# 해시 테이블(Hash Table)에 대한 이해

### 기본 개념

- **Hash / Hash Function**
    
    - 임의의 입력(Key)을 정수 값으로 변환하는 함수
    - 변환 결과는 해시 테이블의 **인덱스 계산에 사용**        
    - 반드시 정수형 결과를 만들며, 테이블 크기로 **modulo 연산**을 수행함
        
- **Key**
    
    - 데이터를 식별하기 위한 고유 값
    - 해시 함수의 입력값
        
- **Value**
    
    - Key에 대응하여 저장되는 실제 데이터
        
- **Bucket**
    
    - 해시 함수로 계산된 인덱스에 대응하는 저장 공간
    - 구현 방식에 따라:
        - 단일 슬롯(Open Addressing)
        - 포인터/컨테이너(Chaining)
            
- **Hash Table**
    
    - 해시 함수를 통해 Key를 인덱스로 변환하여  
        **배열 기반 저장소에 직접 접근**하는 자료구조
        
    - 평균적으로 탐색 / 삽입 / 삭제가 **O(1)**
	

---
### 특징 및 장단점

- **장점**
    
    - 평균적으로 탐색 / 삽입 / 삭제가 매우 빠름 (O(1))
    - Key 기반 접근으로 비교 연산이 최소화됨
    - 대량 데이터에서 트리 구조보다 유리한 성능을 가짐
        
- **단점**
    
    - 해시 충돌(Collision)이 발생할 수 있음
    - 해시 함수 품질과 테이블 크기 설계에 성능이 크게 의존
    - 충돌이 심할 경우 **최악의 시간 복잡도 O(n)** 발생 가능
    - Open Addressing 방식은 삭제 구현이 까다로움
        

- O(1)은 **평균적(amortized)** 성능이며, 절대 보장은 아님


---
### 충돌(Collision)과 시간 복잡도

- 서로 다른 Key가 **같은 인덱스**로 매핑될 경우 충돌 발생
	
- 충돌이 없을 경우:
    
    - 탐색 / 삽입 / 삭제 → O(1)
        
- 충돌이 발생한 경우:
    
    - 동일 버킷(또는 탐사 경로) 내에서 추가 탐색 필요
    - 충돌 수에 비례하여 O(n)까지 증가 가능
        

---
### 충돌 해결 방식

#### 1. Open Addressing (개방 주소법)

- 모든 데이터가 **하나의 배열 내부에 직접 저장**
- 충돌 발생 시, 다른 빈 슬롯을 탐색하여 저장
- **탐사(probing)** 를 통해 다음 후보 인덱스를 결정

#### **대표적인 탐사 방식**

- **Linear Probing**
    
    - 고정 간격(+1)으로 탐사
    - Primary Clustering 발생 가능
        
- **Quadratic Probing**
    
    - 제곱 간격(i²)으로 탐사
    - Primary Clustering 완화
    - Secondary Clustering 존재
        
- **Double Hashing**
    
    - 두 번째 해시 함수로 탐사 간격 결정
    - key마다 다른 탐사 패턴
    - 클러스터링 최소화

 - 테이블 크기를 **소수(prime)** 로 유지
 - 적재율(load factor)을 낮게 유지  

#### 2. Chaining (체인 어드레싱)

- 각 버킷이 **컨테이너(Linked List, Dynamic Array 등)** 를 가짐
- 충돌된 항목을 해당 버킷 내부에 저장
- 테이블 크기 제약이 상대적으로 적음
- 삭제 구현이 단순함
   
- 탐색 시간은 평균적으로 O(1),  
- 버킷 길이에 따라 O(n) 가능


---
### 테이블 크기 및 리사이징 정책

- **적재율(Load Factor)**
    
    - Open Addressing: 보통 0.5 ~ 0.7 이하 권장
    - Chaining: 1 이상도 허용 가능
        
- **리사이징(Resizing)**
    
    - 적재율이 임계치를 넘기기 전에 테이블 크기를 확장하고 **재해싱(Rehashing)** 수행
    - 리사이징 비용은 O(n)이지만, 전체적으로는 **Amortized O(1)** 성능 유지
        
- **테이블 크기**
    
    - Open Addressing에서는 **소수(prime)** 사용이 사실상 필수
    - 탐사 알고리즘이 모든 슬롯을 방문하도록 보장하기 위함
        

---
## 최소 구현 API
### 필수 API

1. `insert(key, value)`
    
    - Key–Value 쌍을 저장
    - 동일 Key 존재 시 덮어쓰기 또는 거부 정책 정의
        
2. `remove(key)`
    
    - 해당 Key의 항목을 삭제
    - Open Addressing에서는 Tombstone 정책 필요
        
3. `find(key)` / `get(key)`
    
    - Key에 대응하는 Value 반환
    - 존재하지 않을 경우의 처리 정책 정의
        
4. `contains(key)`
    
    - Key 존재 여부 반환
        
5. `size()`
    
    - 현재 저장된 요소 수 반환
        

---
### 선택 API

1. `clear()`
    
    - 테이블 초기화
        
2. `rehash()` / `resize()`
    
    - 테이블 확장 및 재해싱
        
3. `loadFactor()`
    
    - 현재 적재율 반환
        

---
### 구현 시 기본 규칙

- 해시 함수는 **균등 분포**를 목표로 설계
- 충돌 해결 전략(Open Addressing / Chaining)을 명확히 선택
- Open Addressing 사용 시:
    
    - 테이블 크기는 소수
    - 탐사 알고리즘이 전체 슬롯을 순회 가능해야 함
    
- 평균 O(1)은 **확률적 성질**임을 항상 전제로 이해
    

---